{
  "_comment": [
    "이 파일은 exclusions.json 구조 가이드 템플릿입니다.",
    "실제 파일: patches/exclusions.json (전역), patches/{mod_id}/exclusions.json (모드 전용)",
    "",
    "=== 제외 수단 선택 원칙 (최소 적용 원칙) ===",
    "",
    "제외 수단은 범위가 좁은 것부터 순서대로 적용하십시오.",
    "가장 정밀한 수단으로 문제를 해결하면 부작용(다른 문자열까지 번역 차단)이 최소화됩니다.",
    "",
    "────────────────────────────────────────────────────────────",
    "1. blocked_classes  (가장 정밀, 권장 기본 수단)",
    "────────────────────────────────────────────────────────────",
    "  대상: UI 문자열이 없는 유틸리티/설정/직렬화 클래스 전체.",
    "  효과: 해당 .class 파일 전체가 패치에서 제외 (원본 그대로 복사).",
    "  특징: 클래스 내 모든 문자열이 한 번에 보호되므로 누락 위험 없음.",
    "  사용 기준:",
    "    - XStream alias 등록 클래스 (세이브 파일 직렬화 키 보호)",
    "    - faction ID / 이벤트 코드 등 내부 키를 .equals()로 비교하는 유틸 클래스",
    "    - 비트맵 폰트로만 렌더링되는 런처 UI 클래스",
    "    - DRM 인증 키 파생에 사용되는 클래스",
    "  형식:",
    "    - 'com/example/MyClass.class'  → 특정 클래스",
    "    - 'com/example/pkg/'           → 패키지 전체 (끝에 '/' 필수)",
    "",
    "  예시 (실제 적용 사례):",
    "    'com/fs/starfarer/campaign/accidents/A.class'     ← DRM 키 파생 클래스",
    "    'com/fs/starfarer/launcher/'                       ← 비트맵 폰트 런처 패키지",
    "    'exerelin/plugins/XStreamConfig.class'             ← 110개 XStream alias",
    "    'exerelin/utilities/NexConfig.class'               ← neutral faction ID 비교",
    "",
    "────────────────────────────────────────────────────────────",
    "2. blocked_jar_strings  (중간, 동적 키 구성에만 사용)",
    "────────────────────────────────────────────────────────────",
    "  대상: JAR 상수 풀에서 동적 키 구성에 쓰이는 문자열 리터럴.",
    "  효과: JAR 패칭에서만 제외. 데이터 파일(JSON/CSV) 번역에는 영향 없음.",
    "  특징: 동적으로 키를 조합하는 경우, 클래스 전체 차단 없이 해당 리터럴만 보호.",
    "  사용 기준:",
    "    - 'header_' + id 형태로 조합되어 config 조회 키가 되는 문자열",
    "    - 클래스 내에 UI 문자열도 함께 있어서 blocked_classes를 쓰면 번역이 손실되는 경우",
    "  형식: 문자열 리터럴 (정확히 일치, 대소문자 구분)",
    "",
    "  예시:",
    "    'invasions'  ← LunaConfigHelper.addHeader(\"invasions\", ...) → 'header_invasions' 조회",
    "                    (번역하면 'header_침공' = 존재하지 않는 키 → 런타임 오류)",
    "",
    "  주의: 이 방식은 blocked_classes로 해결할 수 없을 때만 사용.",
    "    동적 키 구성 클래스에 UI 문자열이 없다면 그냥 blocked_classes에 추가하는 게 더 안전.",
    "",
    "────────────────────────────────────────────────────────────",
    "3. blocked_strings  (최후의 수단, 광범위 적용)",
    "────────────────────────────────────────────────────────────",
    "  대상: JAR 패칭 + 데이터 파일(JSON/CSV) 번역 양쪽에서 모두 차단해야 하는 문자열.",
    "  효과: 번역 사전에 있어도 JAR과 데이터 파일 어디서도 번역되지 않음.",
    "  사용 기준 (모두 만족해야 함):",
    "    - 다수의 클래스에 걸쳐 JSON/CSV 키로 사용됨 (→ 클래스 단위 차단 불가)",
    "    - 데이터 파일에서도 번역이 불필요함 (번역 시 키 오염 발생)",
    "    - blocked_classes + blocked_jar_strings로 해결이 불가능한 경우",
    "  형식: 문자열 리터럴 (정확히 일치)",
    "",
    "  예시:",
    "    'abstain', 'ceasefire', 'diplomacy'  ← 이벤트 키 / 상태 코드",
    "    (Nexerelin에서 여러 클래스에 걸쳐 getString(\"diplomacy\") 형태로 사용)",
    "",
    "  경고: 이 목록의 문자열은 번역 사전에 있어도 완전히 무시됨.",
    "    부작용을 최소화하려면 목록을 가능한 한 짧게 유지할 것.",
    "    단순 ID 오염은 blocked_classes로 더 정밀하게 해결 가능한 경우가 많음."
  ],

  "blocked_classes": [
    "예시: 'com/example/pkg/'  또는  'com/example/MyClass.class'"
  ],

  "blocked_jar_strings": [
    "예시: 'invasions'"
  ],

  "blocked_strings": [
    "예시: 'someKey'"
  ]
}
